<script>
const enableAudioBtn = document.getElementById("enableAudioBtn");
const toggleBtn = document.getElementById("toggleBtn");
const replayAllBtn = document.getElementById("replayAllBtn");
const clearBtn = document.getElementById("clearBtn");
const translationsDiv = document.getElementById("translations");
const liveText = document.getElementById("liveText");
const fromLang = document.getElementById("fromLang");
const toLang = document.getElementById("toLang");

const langMap = { 
  "es": "es-ES",
  "en": "en-US",
  "sv": "sv-SE",
  "fr": "fr-FR",
  "de": "de-DE"
};

let recognition;
let listening = false;
let allTranslations = [];
let audioEnabled = false;
let silenceTimer = null;

// Buffers for speech management
let interimBuffer = "";
let finalBuffer = "";

enableAudioBtn.addEventListener("click", () => {
  const utterance = new SpeechSynthesisUtterance("Audio Enabled");
  speechSynthesis.speak(utterance);
  audioEnabled = true;
  enableAudioBtn.disabled = true;
  enableAudioBtn.textContent = "Audio Enabled";
});

if ("webkitSpeechRecognition" in window) {
  recognition = new webkitSpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;

  recognition.onresult = (event) => {
    // Clear silence timer at the beginning of any new audio
    if (silenceTimer) {
      clearTimeout(silenceTimer);
      silenceTimer = null;
    }

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = event.results[i][0].transcript.trim();

      if (!transcript) continue;

      if (event.results[i].isFinal) {
        // FINAL RESULT â€” commit immediately
        interimBuffer = "";
        finalBuffer = transcript;

        liveText.textContent = "ðŸŽ™ï¸ " + finalBuffer;

        commitChunk(finalBuffer);
        finalBuffer = "";
      } else {
        // INTERIM RESULT
        interimBuffer = transcript;
        liveText.textContent = "ðŸŽ™ï¸ " + interimBuffer;

        // If no final result follows within 1200ms, commit interim
        silenceTimer = setTimeout(() => {
          if (interimBuffer) {
            commitChunk(interimBuffer);
            interimBuffer = "";
            liveText.textContent = "ðŸŽ™ï¸ â€¦";
          }
        }, 1200);
      }
    }
  };

  recognition.onerror = (e) => console.warn("Recognition error:", e);

} else {
  alert("Speech Recognition not supported in this browser.");
}

function commitChunk(text) {
  if (!text || !text.trim()) return;

  const from = fromLang.value;
  const to = toLang.value;

  fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${from}|${to}`)
    .then(res => res.json())
    .then(data => {
      const translated = data?.responseData?.translatedText || "(translation failed)";
      addTranslation(text, translated);
      if (audioEnabled) speak(translated, langMap[to]);
    })
    .catch(() => addTranslation(text, "(translation failed)"));
}

function addTranslation(original, translated) {
  const chunkDiv = document.createElement("div");
  chunkDiv.className = "chunk";
  chunkDiv.innerHTML = `<strong>${original}</strong> â†’ ${translated}`;

  const replayBtn = document.createElement("button");
  replayBtn.textContent = "ðŸ”Š";
  replayBtn.className = "replayBtn";
  replayBtn.onclick = () => speak(translated, langMap[toLang.value]);

  chunkDiv.appendChild(replayBtn);
  translationsDiv.appendChild(chunkDiv);
  translationsDiv.scrollTop = translationsDiv.scrollHeight;

  allTranslations.push(translated);
}

function speak(text, langCode) {
  const utterance = new SpeechSynthesisUtterance(text);
  const voices = speechSynthesis.getVoices();
  const match = voices.find(v => v.lang.startsWith(langCode));
  if (match) utterance.voice = match;
  utterance.lang = langCode;
  speechSynthesis.speak(utterance);
}

toggleBtn.addEventListener("click", () => {
  if (!listening) {
    recognition.lang = langMap[fromLang.value];
    recognition.start();
    listening = true;
    toggleBtn.textContent = "Stop";
  } else {
    recognition.stop();
    listening = false;
    toggleBtn.textContent = "Start";
    if (silenceTimer) clearTimeout(silenceTimer);

    // Commit any leftover interim text
    if (interimBuffer) {
      commitChunk(interimBuffer);
      interimBuffer = "";
    }
  }
});

replayAllBtn.addEventListener("click", () => {
  if (allTranslations.length === 0) {
    alert("No translations to replay.");
    return;
  }

  allTranslations.forEach((text, i) => {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = langMap[toLang.value];
    setTimeout(() => speechSynthesis.speak(utterance), i * 1500);
  });
});

clearBtn.addEventListener("click", () => {
  if (!confirm("Clear all translations?")) return;

  translationsDiv.innerHTML = "";
  liveText.textContent = "ðŸŽ™ï¸ Live text will appear here...";
  allTranslations = [];
  speechSynthesis.cancel();
});

window.speechSynthesis.onvoiceschanged = () => {};
</script>
