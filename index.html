<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Real-Time Translator</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
  button { padding: 12px 20px; margin: 10px; font-size: 16px; border-radius: 10px; border: none; background: #007BFF; color: white; cursor: pointer; }
  button:disabled { background: gray; cursor: not-allowed; }
  select { padding: 8px; font-size: 16px; margin: 5px; }
  #translations, #liveText { margin-top: 20px; text-align: left; max-width: 500px; margin-left: auto; margin-right: auto; background: #f8f8f8; padding: 15px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
  #translations { max-height: 250px; overflow-y: auto; }
  .chunk { padding: 5px 35px 5px 5px; margin-bottom: 5px; border-radius: 5px; background-color: #e0f7fa; position: relative; }
  .replayBtn { position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: #007BFF; color: white; border: none; border-radius: 5px; padding: 2px 5px; cursor: pointer; font-size: 12px; }
  #liveText { font-style: italic; color: #333; }
  .status { margin-top: 10px; padding: 10px; border-radius: 5px; font-size: 14px; }
  .status.error { background: #ffebee; color: #c62828; }
  .status.success { background: #e8f5e9; color: #2e7d32; }
</style>
</head>
<body>

<h1>Real-Time Translator 🌍</h1>
<p>Select languages and press Start:</p>

<button id="enableAudioBtn">🔊 Enable Audio</button>

<label for="fromLang">🎤 Input Language:</label>
<select id="fromLang">
  <option value="en">English</option>
  <option value="es">Spanish</option>
  <option value="sv">Swedish</option>
  <option value="fr">French</option>
</select>

<label for="toLang">🔊 Output Language:</label>
<select id="toLang">
  <option value="en">English</option>
  <option value="es">Spanish</option>
  <option value="sv">Swedish</option>
  <option value="fr">French</option>
</select>

<br><br>
<button id="toggleBtn">▶ Start</button>
<button id="replayAllBtn">🔁 Replay All</button>
<button id="clearBtn">🧹 Clear All</button>

<div id="statusDiv" class="status" style="display:none;"></div>
<div id="liveText">🎙️ Live text will appear here...</div>
<div id="translations"></div>

<script>
const enableAudioBtn = document.getElementById("enableAudioBtn");
const toggleBtn = document.getElementById("toggleBtn");
const replayAllBtn = document.getElementById("replayAllBtn");
const clearBtn = document.getElementById("clearBtn");
const translationsDiv = document.getElementById("translations");
const liveText = document.getElementById("liveText");
const fromLang = document.getElementById("fromLang");
const toLang = document.getElementById("toLang");
const statusDiv = document.getElementById("statusDiv");

const langMap = { "es":"es-ES", "en":"en-US", "sv":"sv-SE", "fr":"fr-FR" };

let recognition;
let currentTranscript = "";
let lastSpeechTime = 0;
let listening = false;
let allTranslations = [];
let audioEnabled = false;
let voicesLoaded = false;

// Load voices and ensure they're available
function loadVoices() {
  return new Promise((resolve) => {
    let voices = speechSynthesis.getVoices();
    if (voices.length > 0) {
      voicesLoaded = true;
      resolve(voices);
    } else {
      speechSynthesis.onvoiceschanged = () => {
        voices = speechSynthesis.getVoices();
        voicesLoaded = true;
        resolve(voices);
      };
    }
  });
}

// Show status message
function showStatus(message, isError = false) {
  statusDiv.textContent = message;
  statusDiv.className = isError ? "status error" : "status success";
  statusDiv.style.display = "block";
  setTimeout(() => {
    statusDiv.style.display = "none";
  }, 3000);
}

enableAudioBtn.addEventListener("click", async () => {
  try {
    // Load voices first
    await loadVoices();
    
    // Test speech synthesis
    const testUtterance = new SpeechSynthesisUtterance("Audio enabled");
    testUtterance.volume = 0.1; // Quiet test
    
    testUtterance.onstart = () => {
      audioEnabled = true;
      enableAudioBtn.disabled = true;
      enableAudioBtn.textContent = "✅ Audio Enabled";
      showStatus("Audio enabled successfully!");
    };
    
    testUtterance.onerror = (e) => {
      console.error("Speech synthesis error:", e);
      showStatus("Audio error: " + e.error, true);
    };
    
    speechSynthesis.speak(testUtterance);
    
  } catch (error) {
    console.error("Audio initialization error:", error);
    showStatus("Could not enable audio. Please check device settings.", true);
  }
});

if ("webkitSpeechRecognition" in window) {
  recognition = new webkitSpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;

  recognition.onresult = (event) => {
    let interimTranscript = "";
    let finalTranscript = "";
    const now = Date.now();

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = (event.results[i][0].transcript || "").trim();
      if (event.results[i].isFinal) {
        finalTranscript += transcript + " ";
      } else {
        interimTranscript += transcript + " ";
      }
    }

    if (interimTranscript) {
      liveText.textContent = "🎙️ " + interimTranscript;
      currentTranscript = interimTranscript;
      lastSpeechTime = now;
    }

    if (finalTranscript) {
      liveText.textContent = "🎙️ " + finalTranscript;
      currentTranscript = finalTranscript;
      commitChunk();
    }

    if (lastSpeechTime && now - lastSpeechTime > 250) {
      commitChunk();
    }
  };

  recognition.onerror = (e) => { 
    console.warn("Recognition error:", e);
    if (e.error === "no-speech") {
      showStatus("No speech detected. Try speaking again.", true);
    } else {
      showStatus("Recognition error: " + e.error, true);
    }
  };
} else {
  alert("Speech Recognition not supported in this browser.");
}

function commitChunk() {
  const transcript = currentTranscript.trim();
  if (!transcript) return;

  currentTranscript = "";
  lastSpeechTime = 0;
  liveText.textContent = "🎙️ …";

  const from = fromLang.value;
  const to = toLang.value;

  fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(transcript)}&langpair=${from}|${to}`)
    .then(res => res.json())
    .then(data => {
      const translated = data?.responseData?.translatedText || "(translation failed)";
      addTranslation(transcript, translated);
      if(audioEnabled) speak(translated, langMap[to]);
    })
    .catch((error) => {
      console.error("Translation error:", error);
      addTranslation(transcript, "(translation failed)");
      showStatus("Translation error. Please try again.", true);
    });
}

function addTranslation(original, translated) {
  const chunkDiv = document.createElement("div");
  chunkDiv.className = "chunk";
  chunkDiv.innerHTML = `<strong>${original}</strong> → ${translated}`;
  const replayBtn = document.createElement("button");
  replayBtn.textContent = "🔊";
  replayBtn.className = "replayBtn";
  replayBtn.onclick = () => speak(translated, langMap[toLang.value]);
  chunkDiv.appendChild(replayBtn);

  translationsDiv.appendChild(chunkDiv);
  translationsDiv.scrollTop = translationsDiv.scrollHeight;

  allTranslations.push(translated);
}

function speak(text, langCode) {
  if (!audioEnabled) {
    showStatus("Please enable audio first!", true);
    return;
  }
  
  // Cancel any ongoing speech
  speechSynthesis.cancel();
  
  const utterance = new SpeechSynthesisUtterance(text);
  const voices = speechSynthesis.getVoices();
  
  // Better voice matching - try exact match first, then language prefix
  let match = voices.find(v => v.lang === langCode);
  if (!match) {
    match = voices.find(v => v.lang.startsWith(langCode.substring(0, 2)));
  }
  
  if (match) {
    utterance.voice = match;
  }
  
  utterance.lang = langCode;
  utterance.rate = 0.9; // Slightly slower for clarity
  
  utterance.onerror = (e) => {
    console.error("Speech synthesis error:", e);
    if (e.error === "not-allowed") {
      showStatus("Audio blocked. Please enable audio again.", true);
      audioEnabled = false;
      enableAudioBtn.disabled = false;
      enableAudioBtn.textContent = "🔊 Enable Audio";
    } else {
      showStatus("Speech error: " + e.error, true);
    }
  };
  
  speechSynthesis.speak(utterance);
}

// Toggle start/stop
toggleBtn.addEventListener("click", () => {
  if (!listening) {
    recognition.lang = langMap[fromLang.value];
    recognition.start();
    listening = true;
    toggleBtn.textContent = "⏹ Stop";
    showStatus("Listening...");
  } else {
    recognition.stop();
    listening = false;
    toggleBtn.textContent = "▶ Start";
    commitChunk();
    showStatus("Stopped listening");
  }
});

// Replay all translations
replayAllBtn.addEventListener("click", () => {
  if (!audioEnabled) {
    showStatus("Please enable audio first!", true);
    return;
  }
  
  if (allTranslations.length === 0) {
    showStatus("No translations to replay yet!", true);
    return;
  }
  
  // Cancel any ongoing speech
  speechSynthesis.cancel();
  
  showStatus(`Replaying ${allTranslations.length} translations...`);
  
  allTranslations.forEach((text, i) => {
    setTimeout(() => {
      const utterance = new SpeechSynthesisUtterance(text);
      const voices = speechSynthesis.getVoices();
      const targetLang = langMap[toLang.value];
      
      let match = voices.find(v => v.lang === targetLang);
      if (!match) {
        match = voices.find(v => v.lang.startsWith(targetLang.substring(0, 2)));
      }
      if (match) utterance.voice = match;
      
      utterance.lang = targetLang;
      utterance.rate = 0.9;
      
      speechSynthesis.speak(utterance);
    }, i * 1500);
  });
});

// Clear all with confirmation
clearBtn.addEventListener("click", () => {
  const confirmClear = confirm("Are you sure you want to clear all translations?");
  if (!confirmClear) return;
  translationsDiv.innerHTML = "";
  liveText.textContent = "🎙️ Live text will appear here...";
  allTranslations = [];
  speechSynthesis.cancel();
  showStatus("All translations cleared");
});

// Load voices on startup
loadVoices();
</script>
</body>
</html>
