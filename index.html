<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Real-Time Translator</title>

  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
    button {
      padding: 12px 20px; margin: 10px; font-size: 16px;
      border-radius: 10px; border: none; background: #007BFF; color: white; cursor: pointer;
    }
    button:disabled { background: gray; cursor: not-allowed; }
    select { padding: 8px; font-size: 16px; margin: 5px; }

    #translations, #liveText {
      margin-top: 20px; text-align: left; max-width: 560px;
      margin-left: auto; margin-right: auto; background: #f8f8f8;
      padding: 15px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      word-wrap: break-word;
    }
    #translations { max-height: 280px; overflow-y: auto; }
    .chunk {
      padding: 8px 42px 8px 8px; margin-bottom: 8px; border-radius: 8px;
      background-color: #e0f7fa; position: relative;
    }
    .replayBtn {
      position: absolute; right: 8px; top: 50%; transform: translateY(-50%);
      background: #007BFF; color: white; border: none; border-radius: 6px;
      padding: 4px 8px; cursor: pointer; font-size: 12px;
    }
    #liveText { font-style: italic; color: #333; }
  </style>
</head>

<body>
  <h1>Real-Time Translator üåç</h1>
  <p>Select languages and press Start:</p>

  <button id="enableAudioBtn">üîä Enable Audio</button>

  <label for="fromLang">üé§ Input Language:</label>
  <select id="fromLang">
    <option value="en">English</option>
    <option value="es">Spanish</option>
    <option value="fr">French</option>
    <option value="de">German</option>
    <option value="sv">Swedish</option>
  </select>

  <label for="toLang">üîä Output Language:</label>
  <select id="toLang">
    <option value="en">English</option>
    <option value="es">Spanish</option>
    <option value="fr">French</option>
    <option value="de">German</option>
    <option value="sv">Swedish</option>
  </select>

  <br /><br />

  <button id="toggleBtn">‚ñ∂ Start</button>
  <button id="replayAllBtn">üîÅ Replay All</button>
  <button id="clearBtn">üßπ Clear All</button>

  <div id="liveText">üéôÔ∏è Live text will appear here...</div>
  <div id="translations"></div>

  <script>
    const enableAudioBtn = document.getElementById("enableAudioBtn");
    const toggleBtn = document.getElementById("toggleBtn");
    const replayAllBtn = document.getElementById("replayAllBtn");
    const clearBtn = document.getElementById("clearBtn");
    const translationsDiv = document.getElementById("translations");
    const liveText = document.getElementById("liveText");
    const fromLang = document.getElementById("fromLang");
    const toLang = document.getElementById("toLang");

    const langMap = {
      es: "es-ES",
      en: "en-US",
      sv: "sv-SE",
      fr: "fr-FR",
      de: "de-DE"
    };

    // ---- iPhone-friendly tuning knobs ----
    const SILENCE_MS = 1100;          // bigger = fewer requests, faster overall on mobile
    const MIN_CHARS_TO_SEND = 6;      // prevents tiny chunks
    const MAX_BUFFER_CHARS = 220;     // force send if user talks a long time
    const TRANSLATE_TIMEOUT_MS = 9000;

    let recognition = null;
    let listening = false;

    let finalBuffer = "";     // confirmed text
    let interimBuffer = "";   // live partial
    let lastFinalAdded = "";  // de-dupe for iOS repeated finals
    let silenceTimer = null;

    let allTranslations = [];
    let audioEnabled = false;

    let translateAbort = null;

    // --- AUDIO: must be user-activated on iOS ---
    enableAudioBtn.addEventListener("click", () => {
      audioEnabled = true;
      enableAudioBtn.disabled = true;
      enableAudioBtn.textContent = "‚úÖ Audio Enabled";

      // ‚ÄúWarm up‚Äù voices on iOS
      const u = new SpeechSynthesisUtterance("Audio enabled");
      u.lang = "en-US";
      speechSynthesis.speak(u);
    });

    function supportsSpeechRecognition() {
      return ("webkitSpeechRecognition" in window) || ("SpeechRecognition" in window);
    }

    function createRecognition() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      const r = new SR();

      // iOS/Safari can be weird with continuous; still try, but we auto-restart on end.
      r.continuous = true;
      r.interimResults = true;

      r.onresult = (event) => {
        let newInterim = "";

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const t = (res[0].transcript || "").trim();
          if (!t) continue;

          if (res.isFinal) {
            // iOS sometimes repeats the same final phrase; de-dupe
            if (t !== lastFinalAdded) {
              finalBuffer += (t + " ");
              lastFinalAdded = t;
            }
          } else {
            newInterim += (t + " ");
          }
        }

        interimBuffer = newInterim.trim();

        // Display combined, but DO NOT translate interim
        const combined = (finalBuffer + " " + interimBuffer).trim();
        liveText.textContent = combined ? ("üéôÔ∏è " + combined) : "üéôÔ∏è ‚Ä¶";

        // Reset silence timer
        if (silenceTimer) clearTimeout(silenceTimer);

        // Commit on silence OR if FINAL buffer is getting huge
        const finalLen = finalBuffer.trim().length;
        if (finalLen >= MAX_BUFFER_CHARS) {
          commitChunk(); // force send
        } else {
          silenceTimer = setTimeout(commitChunk, SILENCE_MS);
        }
      };

      r.onerror = (e) => {
        console.warn("Recognition error:", e);
      };

      r.onend = () => {
        // Safari iOS often stops randomly. If user still wants listening, restart.
        if (listening) {
          try {
            r.lang = langMap[fromLang.value];
            r.start();
          } catch (err) {
            console.warn("Restart failed:", err);
          }
        }
      };

      return r;
    }

    function safeSetListeningUI(isOn) {
      listening = isOn;
      toggleBtn.textContent = isOn ? "‚èπ Stop" : "‚ñ∂ Start";
    }

    function commitChunk() {
      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }

      // ‚úÖ ONLY translate finalized text
      const textToTranslate = finalBuffer.trim();

      // clear buffers
      finalBuffer = "";
      interimBuffer = "";
      lastFinalAdded = "";

      if (!textToTranslate || textToTranslate.length < MIN_CHARS_TO_SEND) {
        liveText.textContent = "üéôÔ∏è ‚Ä¶";
        return;
      }

      liveText.textContent = "‚è≥ Translating‚Ä¶";

      const from = fromLang.value;
      const to = toLang.value;

      // Cancel any in-flight translation so mobile doesn‚Äôt ‚Äúqueue‚Äù old ones.
      if (translateAbort) translateAbort.abort();
      translateAbort = new AbortController();

      const url =
        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToTranslate)}&langpair=${from}|${to}`;

      const timeout = setTimeout(() => {
        try { translateAbort.abort(); } catch {}
      }, TRANSLATE_TIMEOUT_MS);

      fetch(url, { signal: translateAbort.signal })
        .then((res) => res.json())
        .then((data) => {
          clearTimeout(timeout);

          const translated = data?.responseData?.translatedText || "(translation failed)";
          addTranslation(textToTranslate, translated);

          if (audioEnabled) speak(translated, langMap[to]);
          liveText.textContent = "üéôÔ∏è ‚Ä¶";
        })
        .catch((err) => {
          clearTimeout(timeout);
          if (err?.name === "AbortError") return; // expected cancellation
          addTranslation(textToTranslate, "(translation failed)");
          liveText.textContent = "üéôÔ∏è ‚Ä¶";
        });
    }

    function addTranslation(original, translated) {
      const chunkDiv = document.createElement("div");
      chunkDiv.className = "chunk";
      chunkDiv.innerHTML = `<strong>${escapeHtml(original)}</strong><br/>‚Üí ${escapeHtml(translated)}`;

      const replayBtn = document.createElement("button");
      replayBtn.textContent = "üîä";
      replayBtn.className = "replayBtn";
      replayBtn.onclick = () => speak(translated, langMap[toLang.value]);

      chunkDiv.appendChild(replayBtn);
      translationsDiv.appendChild(chunkDiv);
      translationsDiv.scrollTop = translationsDiv.scrollHeight;

      allTranslations.push(translated);
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function pickVoice(langCode) {
      const voices = speechSynthesis.getVoices() || [];
      const prefix = (langCode || "").split("-")[0];
      return (
        voices.find(v => v.lang === langCode) ||
        voices.find(v => v.lang && v.lang.startsWith(prefix)) ||
        null
      );
    }

    function speak(text, langCode) {
      try {
        speechSynthesis.cancel(); // prevents long mobile queueing
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = langCode;

        const voice = pickVoice(langCode);
        if (voice) utterance.voice = voice;

        speechSynthesis.speak(utterance);
      } catch (e) {
        console.warn("Speak failed:", e);
      }
    }

    toggleBtn.addEventListener("click", () => {
      if (!supportsSpeechRecognition()) {
        alert("Speech Recognition is not fully supported on this iPhone browser. Try Safari directly (not inside an embedded webview).");
        return;
      }

      if (!recognition) recognition = createRecognition();

      if (!listening) {
        // clear any leftover buffers
        finalBuffer = "";
        interimBuffer = "";
        lastFinalAdded = "";
        liveText.textContent = "üéôÔ∏è Listening‚Ä¶";

        try {
          recognition.lang = langMap[fromLang.value];
          recognition.start();
          safeSetListeningUI(true);
        } catch (e) {
          console.warn("Start failed:", e);
          alert("Could not start mic. Make sure Safari has microphone permission for this site.");
        }
      } else {
        safeSetListeningUI(false);
        try { recognition.stop(); } catch {}
        commitChunk(); // translate whatever is left (final only)
      }
    });

    replayAllBtn.addEventListener("click", () => {
      if (allTranslations.length === 0) {
        alert("No translations to replay yet!");
        return;
      }
      if (!audioEnabled) {
        alert("Tap 'Enable Audio' first (required on iPhone).");
        return;
      }

      speechSynthesis.cancel();
      let i = 0;

      const speakNext = () => {
        if (i >= allTranslations.length) return;
        const u = new SpeechSynthesisUtterance(allTranslations[i]);
        u.lang = langMap[toLang.value];
        const v = pickVoice(u.lang);
        if (v) u.voice = v;

        u.onend = () => { i++; speakNext(); };
        u.onerror = () => { i++; speakNext(); };

        speechSynthesis.speak(u);
      };

      speakNext();
    });

    clearBtn.addEventListener("click", () => {
      if (!confirm("Are you sure you want to clear all translations?")) return;
      translationsDiv.innerHTML = "";
      liveText.textContent = "üéôÔ∏è Live text will appear here...";
      allTranslations = [];
      finalBuffer = "";
      interimBuffer = "";
      lastFinalAdded = "";
      if (silenceTimer) clearTimeout(silenceTimer);
      speechSynthesis.cancel();
      if (translateAbort) translateAbort.abort();
    });

    // iOS loads voices lazily
    window.speechSynthesis.onvoiceschanged = () => {};
  </script>
</body>
</html>

