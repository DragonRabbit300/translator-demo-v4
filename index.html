<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Real-Time Translator</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  
  body { 
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
    color: #1a202c;
  }
  
  .container {
    max-width: 900px;
    margin: 0 auto;
  }
  
  .header {
    text-align: center;
    margin-bottom: 40px;
    animation: fadeIn 0.6s ease-out;
  }
  
  .header h1 {
    color: white;
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 10px;
    text-shadow: 0 2px 10px rgba(0,0,0,0.2);
  }
  
  .header p {
    color: rgba(255,255,255,0.9);
    font-size: 1.1rem;
  }
  
  .card {
    background: white;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    margin-bottom: 20px;
    animation: slideUp 0.6s ease-out;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  @keyframes slideUp {
    from { opacity: 0; transform: translateY(30px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  button { 
    padding: 14px 28px;
    margin: 8px 5px;
    font-size: 15px;
    font-weight: 600;
    border-radius: 12px;
    border: none;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
  }
  
  button:hover:not(:disabled) { 
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
  }
  
  button:active:not(:disabled) {
    transform: translateY(0);
  }
  
  button:disabled { 
    background: linear-gradient(135deg, #cbd5e0 0%, #a0aec0 100%);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }
  
  button.secondary {
    background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
    box-shadow: 0 4px 15px rgba(72, 187, 120, 0.4);
  }
  
  button.secondary:hover:not(:disabled) {
    box-shadow: 0 6px 20px rgba(72, 187, 120, 0.6);
  }
  
  button.danger {
    background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
    box-shadow: 0 4px 15px rgba(245, 101, 101, 0.4);
  }
  
  select, input { 
    padding: 12px 16px;
    font-size: 15px;
    margin: 5px;
    border-radius: 12px;
    border: 2px solid #e2e8f0;
    background: white;
    transition: all 0.2s;
    font-family: inherit;
  }
  
  select:focus, input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  }
  
  input[type="text"] { width: 100%; max-width: 500px; }
  
  .controls { 
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    align-items: center;
    margin: 25px 0;
  }
  
  .control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #f7fafc;
    padding: 10px 20px;
    border-radius: 12px;
  }
  
  .control-group label {
    font-weight: 600;
    color: #4a5568;
    font-size: 14px;
  }
  
  .font-controls { 
    text-align: center;
    margin: 20px 0;
  }
  
  .font-controls label {
    font-weight: 600;
    color: #4a5568;
    margin-right: 10px;
  }
  
  .font-controls button { 
    padding: 10px 20px;
    font-size: 14px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  }
  
  .action-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
    margin: 20px 0;
  }
  
  #translations, #liveText { 
    margin-top: 25px;
    background: #f7fafc;
    padding: 25px;
    border-radius: 16px;
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.05);
  }
  
  #translations { 
    max-height: 450px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f7fafc;
  }
  
  #translations::-webkit-scrollbar {
    width: 8px;
  }
  
  #translations::-webkit-scrollbar-track {
    background: #f7fafc;
    border-radius: 10px;
  }
  
  #translations::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 10px;
  }
  
  #translations::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
  }
  
  .chunk { 
    padding: 16px 90px 16px 20px;
    margin-bottom: 12px;
    border-radius: 12px;
    background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
    position: relative;
    word-wrap: break-word;
    transition: all 0.2s;
    animation: chunkAppear 0.4s ease-out;
    border-left: 4px solid #667eea;
  }
  
  @keyframes chunkAppear {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
  }
  
  .chunk:hover {
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
    transform: translateX(4px);
  }
  
  .chunk strong {
    color: #4c51bf;
    font-weight: 600;
  }
  
  .chunk-buttons {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    gap: 6px;
  }
  
  .chunk-buttons button { 
    background: white;
    color: #667eea;
    border: 2px solid #e0e7ff;
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    margin: 0;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  
  .chunk-buttons button:hover { 
    background: #667eea;
    color: white;
    border-color: #667eea;
    transform: scale(1.1);
  }
  
  #liveText { 
    font-style: italic;
    color: #4a5568;
    min-height: 70px;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #fef5e7 0%, #fdebd0 100%);
    border-left: 4px solid #f6ad55;
  }
  
  .status { 
    margin: 20px auto;
    padding: 16px 24px;
    border-radius: 12px;
    font-size: 14px;
    font-weight: 500;
    max-width: 700px;
    text-align: center;
    animation: statusSlide 0.3s ease-out;
  }
  
  @keyframes statusSlide {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .status.error { 
    background: linear-gradient(135deg, #fed7d7 0%, #feb2b2 100%);
    color: #c53030;
    border-left: 4px solid #fc8181;
  }
  
  .status.success { 
    background: linear-gradient(135deg, #c6f6d5 0%, #9ae6b4 100%);
    color: #22543d;
    border-left: 4px solid #48bb78;
  }
  
  .status.warning { 
    background: linear-gradient(135deg, #feebc8 0%, #fbd38d 100%);
    color: #7c2d12;
    border-left: 4px solid #f6ad55;
  }
  
  .loading { display: inline-block; margin-left: 10px; }
  .loading::after {
    content: '...';
    animation: dots 1.5s steps(4, end) infinite;
  }
  
  @keyframes dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
  }
  
  .manual-input { margin: 25px 0; }
  .manual-input textarea {
    width: 100%;
    padding: 16px;
    font-size: 15px;
    border-radius: 12px;
    border: 2px solid #e2e8f0;
    min-height: 100px;
    font-family: inherit;
    resize: vertical;
    transition: all 0.2s;
  }
  
  .manual-input textarea:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  }
  
  .keyboard-hint {
    font-size: 13px;
    color: rgba(255,255,255,0.9);
    text-align: center;
    margin-top: 20px;
    padding: 12px;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    backdrop-filter: blur(10px);
  }
  
  .export-buttons {
    margin: 20px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
  }
  
  .section-title {
    font-size: 18px;
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 15px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .section-title::before {
    content: '';
    width: 4px;
    height: 24px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 2px;
  }
  
  @media (max-width: 600px) {
    body { padding: 10px; }
    .header h1 { font-size: 2rem; }
    .card { padding: 20px; }
    button { padding: 12px 20px; font-size: 14px; }
    .controls { flex-direction: column; }
    .control-group { width: 100%; justify-content: center; }
  }
</style>
</head>
<body>

<div class="container">
  <div class="header">
    <h1>üåç Real-Time Translator</h1>
    <p>Translate speech in real-time with text-to-speech output</p>
  </div>

  <div class="card">
    <div role="alert" aria-live="polite" id="statusDiv" class="status" style="display:none;"></div>

    <div style="text-align: center; margin-bottom: 20px;">
      <button id="enableAudioBtn" aria-label="Enable audio output">üîä Enable Audio</button>
    </div>

    <div class="section-title">Language Settings</div>
    <div class="controls">
      <div class="control-group">
        <label for="fromLang">üé§ Input:</label>
        <select id="fromLang" aria-label="Select input language">
          <option value="auto">Auto-Detect</option>
          <option value="en">English</option>
          <option value="es">Spanish</option>
          <option value="sv">Swedish</option>
          <option value="fr">French</option>
          <option value="de">German</option>
          <option value="it">Italian</option>
          <option value="pt">Portuguese</option>
          <option value="zh">Chinese</option>
          <option value="ja">Japanese</option>
        </select>
      </div>

      <div class="control-group">
        <label for="toLang">üîä Output:</label>
        <select id="toLang" aria-label="Select output language">
          <option value="en">English</option>
          <option value="es">Spanish</option>
          <option value="sv">Swedish</option>
          <option value="fr">French</option>
          <option value="de">German</option>
          <option value="it">Italian</option>
          <option value="pt">Portuguese</option>
          <option value="zh">Chinese</option>
          <option value="ja">Japanese</option>
        </select>
      </div>
    </div>

    <div class="font-controls">
      <label>Text Size:</label>
      <button id="fontDecrease" aria-label="Decrease font size">A-</button>
      <button id="fontIncrease" aria-label="Increase font size">A+</button>
      <button id="fontReset" aria-label="Reset font size">Reset</button>
    </div>

    <div class="action-buttons">
      <button id="toggleBtn" class="secondary" aria-label="Start or stop voice recognition">‚ñ∂ Start (Space)</button>
      <button id="replayAllBtn" aria-label="Replay all translations">üîÅ Replay All (R)</button>
      <button id="clearBtn" class="danger" aria-label="Clear all translations">üßπ Clear (C)</button>
    </div>

    <div class="section-title">Manual Input</div>
    <div class="manual-input">
      <textarea id="manualInput" placeholder="Or type text here for translation..." aria-label="Manual text input"></textarea>
      <div style="text-align: center; margin-top: 10px;">
        <button id="translateManual" aria-label="Translate typed text">‚úèÔ∏è Translate Text (Enter)</button>
      </div>
    </div>

    <div class="export-buttons">
      <button id="exportTxt" aria-label="Export as text file">üìÑ Export TXT</button>
      <button id="exportJson" aria-label="Export as JSON file">üìã Export JSON</button>
      <button id="copyAll" aria-label="Copy all translations to clipboard">üìã Copy All</button>
    </div>
  </div>

  <div class="card">
    <div class="section-title">Live Recognition</div>
    <div id="liveText" role="status" aria-live="polite">üéôÔ∏è Live text will appear here...</div>
  </div>

  <div class="card">
    <div class="section-title">Translation History</div>
    <div id="translations" role="log" aria-label="Translation history"></div>
  </div>

  <div class="keyboard-hint">
    ‚å®Ô∏è Keyboard shortcuts: Space (Start/Stop) ‚Ä¢ R (Replay) ‚Ä¢ C (Clear) ‚Ä¢ Ctrl+Enter (Translate text)
  </div>
</div>

<script>
// Security: Sanitize HTML to prevent XSS
function sanitizeHTML(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// Check HTTPS
if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
  alert('‚ö†Ô∏è Warning: This app requires HTTPS for speech recognition to work properly.');
}

const enableAudioBtn = document.getElementById("enableAudioBtn");
const toggleBtn = document.getElementById("toggleBtn");
const replayAllBtn = document.getElementById("replayAllBtn");
const clearBtn = document.getElementById("clearBtn");
const translationsDiv = document.getElementById("translations");
const liveText = document.getElementById("liveText");
const fromLang = document.getElementById("fromLang");
const toLang = document.getElementById("toLang");
const statusDiv = document.getElementById("statusDiv");
const manualInput = document.getElementById("manualInput");
const translateManual = document.getElementById("translateManual");
const fontDecrease = document.getElementById("fontDecrease");
const fontIncrease = document.getElementById("fontIncrease");
const fontReset = document.getElementById("fontReset");
const exportTxt = document.getElementById("exportTxt");
const exportJson = document.getElementById("exportJson");
const copyAll = document.getElementById("copyAll");

const langMap = { 
  "es":"es-ES", "en":"en-US", "sv":"sv-SE", "fr":"fr-FR",
  "de":"de-DE", "it":"it-IT", "pt":"pt-PT", "zh":"zh-CN", "ja":"ja-JP"
};

let recognition;
let currentTranscript = "";
let lastSpeechTime = 0;
let silenceTimer = null;
let listening = false;
let allTranslations = [];
let audioEnabled = false;
let voicesLoaded = false;
let isOnline = navigator.onLine;
let fontSize = 16;
let translationCache = {};
const MAX_TRANSLATIONS = 100;

// Online/Offline detection
window.addEventListener('online', () => {
  isOnline = true;
  showStatus('Back online! Translations will work again.', false);
});

window.addEventListener('offline', () => {
  isOnline = false;
  showStatus('You are offline. Translation requires internet connection.', true);
});

// Font size controls
function updateFontSize() {
  translationsDiv.style.fontSize = fontSize + 'px';
  liveText.style.fontSize = fontSize + 'px';
  try { localStorage.setItem('fontSize', fontSize); } catch(e) {}
}

fontIncrease.addEventListener('click', () => {
  if (fontSize < 24) {
    fontSize += 2;
    updateFontSize();
    showStatus(`Font size: ${fontSize}px`);
  }
});

fontDecrease.addEventListener('click', () => {
  if (fontSize > 12) {
    fontSize -= 2;
    updateFontSize();
    showStatus(`Font size: ${fontSize}px`);
  }
});

fontReset.addEventListener('click', () => {
  fontSize = 16;
  updateFontSize();
  showStatus('Font size reset to default');
});

// Load saved font size
try {
  const savedSize = localStorage.getItem('fontSize');
  if (savedSize) {
    fontSize = parseInt(savedSize);
    updateFontSize();
  }
} catch (e) {}

// Load voices
function loadVoices() {
  return new Promise((resolve) => {
    let voices = speechSynthesis.getVoices();
    if (voices.length > 0) {
      voicesLoaded = true;
      resolve(voices);
    } else {
      speechSynthesis.onvoiceschanged = () => {
        voices = speechSynthesis.getVoices();
        voicesLoaded = true;
        resolve(voices);
      };
    }
  });
}

function showStatus(message, isError = false, isWarning = false) {
  statusDiv.textContent = message;
  statusDiv.className = isError ? "status error" : (isWarning ? "status warning" : "status success");
  statusDiv.style.display = "block";
  setTimeout(() => {
    statusDiv.style.display = "none";
  }, 3000);
}

enableAudioBtn.addEventListener("click", async () => {
  try {
    await loadVoices();
    const testUtterance = new SpeechSynthesisUtterance("Audio enabled");
    testUtterance.volume = 0.1;
    
    testUtterance.onstart = () => {
      audioEnabled = true;
      enableAudioBtn.disabled = true;
      enableAudioBtn.textContent = "‚úÖ Audio Enabled";
      showStatus("Audio enabled successfully!");
    };
    
    testUtterance.onerror = (e) => {
      console.error("Speech synthesis error:", e);
      showStatus("Audio error: " + e.error, true);
    };
    
    speechSynthesis.speak(testUtterance);
  } catch (error) {
    console.error("Audio initialization error:", error);
    showStatus("Could not enable audio. Please check device settings.", true);
  }
});

// Speech Recognition Setup
if ("webkitSpeechRecognition" in window || "SpeechRecognition" in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;

  recognition.onresult = (event) => {
    let interimTranscript = "";
    let finalTranscript = "";
    const now = Date.now();

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = (event.results[i][0].transcript || "").trim();
      if (event.results[i].isFinal) {
        finalTranscript += transcript + " ";
      } else {
        interimTranscript += transcript + " ";
      }
    }

    if (interimTranscript) {
      liveText.textContent = "üéôÔ∏è " + interimTranscript;
      currentTranscript = interimTranscript;
      lastSpeechTime = now;
      resetSilenceTimer();
    }

    if (finalTranscript) {
      liveText.textContent = "üéôÔ∏è " + finalTranscript;
      currentTranscript = finalTranscript;
      commitChunk();
    }
  };

  recognition.onerror = (e) => { 
    console.warn("Recognition error:", e);
    if (e.error === "no-speech") {
      showStatus("No speech detected. Try speaking again.", false, true);
    } else if (e.error === "audio-capture") {
      showStatus("Microphone error. Check permissions.", true);
    } else if (e.error === "not-allowed") {
      showStatus("Microphone access denied. Please enable it.", true);
    } else {
      showStatus("Recognition error: " + e.error, true);
    }
  };

  recognition.onend = () => {
    if (listening) {
      try {
        recognition.start();
      } catch (e) {
        console.warn("Could not restart recognition:", e);
      }
    }
  };
} else {
  showStatus("Speech Recognition not supported in this browser.", true);
  toggleBtn.disabled = true;
}

function resetSilenceTimer() {
  if (silenceTimer) clearTimeout(silenceTimer);
  silenceTimer = setTimeout(() => {
    if (currentTranscript.trim() && listening) {
      commitChunk();
    }
  }, 1500);
}

function commitChunk() {
  const transcript = currentTranscript.trim();
  if (!transcript) return;

  currentTranscript = "";
  lastSpeechTime = 0;
  liveText.innerHTML = "üéôÔ∏è ‚Ä¶ <span class='loading'></span>";

  if (silenceTimer) {
    clearTimeout(silenceTimer);
    silenceTimer = null;
  }

  translateText(transcript);
}

async function translateText(text, isManual = false) {
  if (!isOnline) {
    showStatus("Cannot translate: You are offline", true);
    liveText.textContent = "üéôÔ∏è Offline - translation unavailable";
    return;
  }

  // Detect language if auto-detect is enabled
  let from = fromLang.value;
  if (from === 'auto') {
    from = await detectLanguage(text);
  }
  const to = toLang.value;
  
  const cacheKey = `${from}|${to}|${text}`;
  if (translationCache[cacheKey]) {
    addTranslation(text, translationCache[cacheKey], isManual);
    if(audioEnabled && !isManual) speak(translationCache[cacheKey], langMap[to]);
    liveText.textContent = "üéôÔ∏è Live text will appear here...";
    return;
  }

  try {
    let translated = null;
    
    try {
      const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${from}|${to}`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        translated = data?.responseData?.translatedText;
      }
    } catch (e) {
      console.warn("MyMemory API failed, trying fallback:", e);
    }
    
    if (!translated) {
      try {
        const response = await fetch('https://libretranslate.de/translate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            q: text,
            source: from === 'auto' ? 'auto' : from,
            target: to,
            format: 'text'
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          translated = data?.translatedText;
        }
      } catch (e) {
        console.warn("LibreTranslate API failed:", e);
      }
    }
    
    if (!translated) {
      showStatus("‚ö†Ô∏è Translation APIs unavailable. Using local mode.", false, true);
      translated = `[${to.toUpperCase()}] ${text}`;
    }
    
    translationCache[cacheKey] = translated;
    addTranslation(text, translated, isManual);
    if(audioEnabled && !isManual) speak(translated, langMap[to]);
    liveText.textContent = "üéôÔ∏è Live text will appear here...";
    
  } catch (error) {
    console.error("Translation error:", error);
    addTranslation(text, `[Error] ${text}`, isManual);
    showStatus("Translation failed. Check console for details.", true);
    liveText.textContent = "üéôÔ∏è Live text will appear here...";
  }
}

function addTranslation(original, translated, skipSpeech = false) {
  if (allTranslations.length >= MAX_TRANSLATIONS) {
    allTranslations.shift();
    const firstChunk = translationsDiv.firstChild;
    if (firstChunk) translationsDiv.removeChild(firstChunk);
  }

  allTranslations.push({ original, translated, timestamp: Date.now() });
  addTranslationToDOM(original, translated, skipSpeech);
  try { localStorage.setItem('translationHistory', JSON.stringify(allTranslations)); } catch(e) {}
}

function addTranslationToDOM(original, translated, skipSpeech = false) {
  const chunkDiv = document.createElement("div");
  chunkDiv.className = "chunk";
  
  const textSpan = document.createElement("span");
  textSpan.innerHTML = `<strong>${sanitizeHTML(original)}</strong> ‚Üí ${sanitizeHTML(translated)}`;
  chunkDiv.appendChild(textSpan);
  
  const buttonsDiv = document.createElement("div");
  buttonsDiv.className = "chunk-buttons";
  
  const replayBtn = document.createElement("button");
  replayBtn.textContent = "üîä";
  replayBtn.setAttribute('aria-label', 'Replay this translation');
  replayBtn.onclick = () => speak(translated, langMap[toLang.value]);
  
  const copyBtn = document.createElement("button");
  copyBtn.textContent = "üìã";
  copyBtn.setAttribute('aria-label', 'Copy this translation');
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(`${original} ‚Üí ${translated}`).then(() => {
      showStatus('Copied to clipboard!');
    }).catch(() => {
      showStatus('Copy failed', true);
    });
  };
  
  const editBtn = document.createElement("button");
  editBtn.textContent = "‚úèÔ∏è";
  editBtn.setAttribute('aria-label', 'Edit and retranslate');
  editBtn.onclick = () => {
    const newText = prompt("Edit text:", original);
    if (newText && newText.trim()) {
      translateText(newText.trim(), true);
    }
  };
  
  buttonsDiv.appendChild(replayBtn);
  buttonsDiv.appendChild(copyBtn);
  buttonsDiv.appendChild(editBtn);
  chunkDiv.appendChild(buttonsDiv);

  translationsDiv.appendChild(chunkDiv);
  translationsDiv.scrollTop = translationsDiv.scrollHeight;
}

function speak(text, langCode) {
  if (!audioEnabled) {
    showStatus("Please enable audio first!", false, true);
    return;
  }
  
  speechSynthesis.cancel();
  
  const utterance = new SpeechSynthesisUtterance(text);
  const voices = speechSynthesis.getVoices();
  
  let match = voices.find(v => v.lang === langCode);
  if (!match) {
    match = voices.find(v => v.lang.startsWith(langCode.substring(0, 2)));
  }
  
  if (match) {
    utterance.voice = match;
  }
  
  utterance.lang = langCode;
  utterance.rate = 0.9;
  
  utterance.onerror = (e) => {
    console.error("Speech synthesis error:", e);
    if (e.error === "not-allowed" || e.error === "interrupted") {
      showStatus("Audio interrupted. Please enable audio again.", false, true);
      audioEnabled = false;
      enableAudioBtn.disabled = false;
      enableAudioBtn.textContent = "üîä Enable Audio";
    } else {
      showStatus("Speech error: " + e.error, true);
    }
  };
  
  speechSynthesis.speak(utterance);
}

// Toggle start/stop
toggleBtn.addEventListener("click", () => {
  if (!listening) {
    // For auto-detect, we need to listen in a default language first
    // Speech recognition doesn't support true auto-detect, so we'll start with English
    // and detect the actual language when we get the transcript
    const lang = fromLang.value === 'auto' ? 'en-US' : langMap[fromLang.value];
    recognition.lang = lang;
    
    if (fromLang.value === 'auto') {
      showStatus("Auto-detect enabled - speak in any language!", false, false);
    }
    
    try {
      recognition.start();
      listening = true;
      toggleBtn.textContent = "‚èπ Stop (Space)";
      toggleBtn.className = "danger";
      showStatus("Listening...");
    } catch (e) {
      showStatus("Could not start recognition: " + e.message, true);
    }
  } else {
    recognition.stop();
    listening = false;
    toggleBtn.textContent = "‚ñ∂ Start (Space)";
    toggleBtn.className = "secondary";
    commitChunk();
    showStatus("Stopped listening");
    if (silenceTimer) {
      clearTimeout(silenceTimer);
      silenceTimer = null;
    }
  }
});

// Manual text translation
translateManual.addEventListener("click", () => {
  const text = manualInput.value.trim();
  if (text) {
    translateText(text, true);
    manualInput.value = "";
  } else {
    showStatus("Please enter text to translate", false, true);
  }
});

// Replay all
replayAllBtn.addEventListener("click", () => {
  if (!audioEnabled) {
    showStatus("Please enable audio first!", false, true);
    return;
  }
  
  if (allTranslations.length === 0) {
    showStatus("No translations to replay yet!", false, true);
    return;
  }
  
  speechSynthesis.cancel();
  showStatus(`Replaying ${allTranslations.length} translations...`);
  
  allTranslations.forEach((item, i) => {
    setTimeout(() => {
      const utterance = new SpeechSynthesisUtterance(item.translated);
      const voices = speechSynthesis.getVoices();
      const targetLang = langMap[toLang.value];
      
      let match = voices.find(v => v.lang === targetLang);
      if (!match) {
        match = voices.find(v => v.lang.startsWith(targetLang.substring(0, 2)));
      }
      if (match) utterance.voice = match;
      
      utterance.lang = targetLang;
      utterance.rate = 0.9;
      
      speechSynthesis.speak(utterance);
    }, i * 1500);
  });
});

// Clear all
clearBtn.addEventListener("click", () => {
  const confirmClear = confirm("Are you sure you want to clear all translations?");
  if (!confirmClear) return;
  translationsDiv.innerHTML = "";
  liveText.textContent = "üéôÔ∏è Live text will appear here...";
  allTranslations = [];
  translationCache = {};
  speechSynthesis.cancel();
  try { localStorage.setItem('translationHistory', JSON.stringify(allTranslations)); } catch(e) {}
  showStatus("All translations cleared");
});

// Export functions
exportTxt.addEventListener("click", () => {
  if (allTranslations.length === 0) {
    showStatus("No translations to export", false, true);
    return;
  }
  
  const text = allTranslations.map(item => 
    `${item.original} ‚Üí ${item.translated}`
  ).join('\n\n');
  
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `translations_${Date.now()}.txt`;
  a.click();
  URL.revokeObjectURL(url);
  showStatus("Exported as TXT file");
});

exportJson.addEventListener("click", () => {
  if (allTranslations.length === 0) {
    showStatus("No translations to export", false, true);
    return;
  }
  
  const json = JSON.stringify(allTranslations, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `translations_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  showStatus("Exported as JSON file");
});

copyAll.addEventListener("click", () => {
  if (allTranslations.length === 0) {
    showStatus("No translations to copy", false, true);
    return;
  }
  
  const text = allTranslations.map(item => 
    `${item.original} ‚Üí ${item.translated}`
  ).join('\n\n');
  
  navigator.clipboard.writeText(text).then(() => {
    showStatus('All translations copied to clipboard!');
  }).catch(() => {
    showStatus('Copy failed', true);
  });
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.target === manualInput) {
    if (e.key === 'Enter' && e.ctrlKey) {
      translateManual.click();
    }
    return;
  }
  
  if (e.key === ' ' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
    e.preventDefault();
    toggleBtn.click();
  } else if (e.key.toLowerCase() === 'r' && !e.ctrlKey && !e.metaKey) {
    e.preventDefault();
    replayAllBtn.click();
  } else if (e.key.toLowerCase() === 'c' && !e.ctrlKey && !e.metaKey) {
    e.preventDefault();
    clearBtn.click();
  }
});

// Handle audio context resume on user interaction
document.addEventListener('click', () => {
  if (audioEnabled && speechSynthesis.paused) {
    speechSynthesis.resume();
  }
}, { once: true });

// Media keys support (headphone pause/play button)
if ('mediaSession' in navigator) {
  navigator.mediaSession.metadata = new MediaMetadata({
    title: 'Real-Time Translator',
    artist: 'Voice Translation',
    album: 'Language Tools'
  });

  // Handle play/pause from media keys (headphones, keyboard, etc.)
  navigator.mediaSession.setActionHandler('play', async () => {
    console.log('Media play button pressed');
    
    // Enable audio if not enabled
    if (!audioEnabled) {
      try {
        await loadVoices();
        const testUtterance = new SpeechSynthesisUtterance("");
        testUtterance.volume = 0.01;
        
        testUtterance.onstart = () => {
          audioEnabled = true;
          enableAudioBtn.disabled = true;
          enableAudioBtn.textContent = "‚úÖ Audio Enabled";
          showStatus("Audio enabled via media button!");
          
          // Start recording after audio is enabled
          if (!listening) {
            toggleBtn.click();
          }
        };
        
        speechSynthesis.speak(testUtterance);
      } catch (error) {
        console.error("Audio initialization error:", error);
        showStatus("Could not enable audio via media button", true);
      }
    } else {
      // Audio already enabled, just start recording
      if (!listening) {
        toggleBtn.click();
      }
    }
  });

  navigator.mediaSession.setActionHandler('pause', () => {
    console.log('Media pause button pressed');
    if (listening) {
      toggleBtn.click();
    }
  });
}

// Alternative: Listen for media key events
document.addEventListener('keydown', (e) => {
  // Media play/pause key
  if (e.key === 'MediaPlayPause' || e.keyCode === 179) {
    e.preventDefault();
    
    if (!listening) {
      // Enable audio if needed, then start
      if (!audioEnabled) {
        enableAudioBtn.click();
        setTimeout(() => {
          if (audioEnabled) {
            toggleBtn.click();
          }
        }, 500);
      } else {
        toggleBtn.click();
      }
    } else {
      toggleBtn.click();
    }
  }
  
  // Media play key
  if (e.key === 'MediaPlay' || e.keyCode === 179) {
    e.preventDefault();
    if (!listening) {
      if (!audioEnabled) {
        enableAudioBtn.click();
        setTimeout(() => {
          if (audioEnabled) {
            toggleBtn.click();
          }
        }, 500);
      } else {
        toggleBtn.click();
      }
    }
  }
  
  // Media pause/stop key
  if (e.key === 'MediaStop' || e.key === 'MediaPause' || e.keyCode === 178 || e.keyCode === 179) {
    e.preventDefault();
    if (listening) {
      toggleBtn.click();
    }
  }
});

// Show media button hint
setTimeout(() => {
  if ('mediaSession' in navigator) {
    showStatus("üí° Tip: You can use your headphone play/pause button to control recording!", false, false);
  }
}, 2000);

// Load voices and history on startup
loadVoices();
try {
  const saved = localStorage.getItem('translationHistory');
  if (saved) {
    allTranslations = JSON.parse(saved);
    allTranslations.forEach(item => {
      addTranslationToDOM(item.original, item.translated, false);
    });
  }
} catch (e) {
  console.error('Error loading history:', e);
}
</script>
</body>
</html>
