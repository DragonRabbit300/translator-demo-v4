<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Real-Time Translator ‚Äî Full</title>
<style>
  :root{
    --blue:#007BFF;
    --accent:#0b84e6;
    --bg:#f6fbff;
    --panel:#f1fbff;
    --card:#eaf9ff;
    --muted:#6b7280;
    --radius:12px;
    --maxwidth:880px;
  }
  html,body{height:100%;margin:0}
  body{
    margin:0;padding:22px;background:var(--bg);font-family:Inter,Segoe UI,Helvetica,Arial,sans-serif;color:#0b1724;
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
  }
  .wrap{max-width:var(--maxwidth);margin:0 auto}
  h1{margin:6px 0 12px;text-align:center;font-weight:600}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;margin-bottom:14px}
  .group{display:flex;gap:8px;align-items:center}
  label{font-size:14px;color:#0b1724}
  select,button{padding:10px 14px;border-radius:10px;border:1px solid rgba(11,24,36,0.08);font-size:15px}
  button{background:var(--blue);color:#fff;cursor:pointer}
  button.secondary{background:var(--accent)}
  button.ghost{background:#fff;color:var(--blue);border:1px solid rgba(11,24,36,0.06)}
  button:disabled{background:gray;cursor:not-allowed}
  .status{background:#fff;padding:12px;border-radius:12px;border:1px solid #e6eef7;margin-bottom:12px;min-height:56px;display:flex;align-items:center}
  .status .text{font-style:italic;color:#334155}
  #translations{max-height:520px;overflow:auto;padding:8px}
  .chunk{background:var(--card);padding:12px;border-radius:12px;margin:10px 0;position:relative;border-left:6px solid var(--blue);box-shadow:0 6px 18px rgba(15,23,42,0.04)}
  .chunk strong{display:block;font-size:16px;margin-bottom:8px}
  .chunk .translated{color:#0b1724}
  .replayBtn{position:absolute;right:10px;top:50%;transform:translateY(-50%);border:none;padding:8px;border-radius:10px;background:var(--blue);color:#fff;cursor:pointer}
  .controls .small{font-size:13px;color:var(--muted)}
  footer{margin-top:10px;text-align:center;color:var(--muted);font-size:13px}
  .note{font-size:13px;color:var(--muted);text-align:center;margin-top:8px}
  @media (max-width:660px){
    .controls{flex-direction:column;gap:12px}
    .group{width:100%;justify-content:center}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Real-Time Translator</h1>

  <div class="controls" role="toolbar" aria-label="controls">
    <div class="group">
      <label for="fromLang">Input:</label>
      <select id="fromLang" aria-label="Input language">
        <option value="en-US">English (US)</option>
        <option value="en-GB">English (UK)</option>
        <option value="es-ES">Spanish</option>
        <option value="fr-FR">French</option>
        <option value="de-DE">German</option>
        <option value="sv-SE">Swedish</option>
      </select>
    </div>

    <div class="group">
      <label for="toLang">Output:</label>
      <select id="toLang" aria-label="Output language">
        <option value="en">English</option>
        <option value="es">Spanish</option>
        <option value="fr">French</option>
        <option value="de">German</option>
        <option value="sv">Swedish</option>
      </select>
    </div>

    <div class="group">
      <button id="enableAudioBtn" class="ghost" title="Enable audio (required gesture on some mobile browsers)">Enable Audio</button>
      <button id="toggleBtn" title="Start/Stop recognition">Start</button>
      <button id="replayAllBtn" class="secondary" title="Replay all translations">Replay All</button>
      <button id="clearBtn" class="secondary" title="Clear All">Clear All</button>
    </div>
  </div>

  <div class="status" role="status" aria-live="polite">
    <div class="text" id="liveText">üéôÔ∏è Live text will appear here...</div>
  </div>

  <div id="translations" aria-live="polite"></div>

  <div class="note">Uses Web Speech (webkitSpeechRecognition) + MyMemory translator (demo). For best results use Chrome on Android or Safari on iOS.</div>
  <footer></footer>
</div>

<script>
/*
  Full single-file translator (complete feature set)
  - Single-file inline JS for GitHub Pages convenience
  - Android/Samsung fixes: continuous=true, controlled interim handling, newline cleanup, commit debounce, auto-restart control
  - Prevent duplicate handlers / double-loading
  - Per-chunk replay + Replay All
  - Enable-audio (TTS unlock)
  - MyMemory used for demo; replace with other API if desired
*/

/* -------------------------
   Configuration & state
   ------------------------- */
const enableAudioBtn = document.getElementById('enableAudioBtn');
const toggleBtn = document.getElementById('toggleBtn');
const replayAllBtn = document.getElementById('replayAllBtn');
const clearBtn = document.getElementById('clearBtn');
const translationsDiv = document.getElementById('translations');
const liveText = document.getElementById('liveText');
const fromLang = document.getElementById('fromLang');
const toLang = document.getElementById('toLang');

// TTS mapping (best-effort)
const langSpeechMap = { "es":"es-ES", "en":"en-US", "fr":"fr-FR", "de":"de-DE", "sv":"sv-SE" };

let recognition = null;
let isListening = false;
let audioEnabled = false;
let interimBuffer = "";            // latest interim text
let lastCommittedFinal = "";       // last final committed (prevents duplicates)
let silenceTimer = null;           // timer for pause-based commit
let allTranslations = [];          // history for replay all
let shouldAutoRestart = false;     // controls auto-restart behavior (only when user expects it)

/* -------------------------
   Utility helpers
   ------------------------- */
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, function(m){
    return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];
  });
}

function cleanTranscript(t) {
  if (!t) return '';
  // Remove HTML newline entity and any actual newline chars; collapse whitespace
  return t.replace(/(&#10;|\r\n|\n|\r)/g, ' ').replace(/\s+/g, ' ').trim();
}

// TTS: speak text in language code
function speak(text, langCode) {
  if (!audioEnabled) return;
  try {
    const u = new SpeechSynthesisUtterance(text);
    const voices = speechSynthesis.getVoices() || [];
    const prefix = (langCode||'').split('-')[0];
    const exact = voices.find(v => v.lang === langCode);
    const fuzzy = voices.find(v => v.lang && v.lang.startsWith(prefix));
    if (exact) u.voice = exact;
    else if (fuzzy) u.voice = fuzzy;
    u.lang = langCode || 'en-US';
    speechSynthesis.speak(u);
  } catch (e) {
    console.warn('TTS speak error:', e);
  }
}

/* -------------------------
   UI helpers
   ------------------------- */
function addTranslation(original, translated) {
  const div = document.createElement('div');
  div.className = 'chunk';
  div.innerHTML = `<strong>${escapeHtml(original)}</strong><div class="translated">‚Üí ${escapeHtml(translated)}</div>`;

  const btn = document.createElement('button');
  btn.className = 'replayBtn';
  btn.title = 'Play translation';
  btn.innerText = 'üîä';
  btn.onclick = () => speak(translated, langSpeechMap[toLang.value] || toLang.value);

  div.appendChild(btn);
  translationsDiv.prepend(div);

  allTranslations.push(translated);
}

/* -------------------------
   Translation API (MyMemory demo)
   Replace with your own service for production.
   ------------------------- */
async function translateText(text, fromCode, toCode) {
  try {
    const q = encodeURIComponent(text);
    const fromRoot = (fromCode || 'en').split('-')[0];
    const toRoot = (toCode || 'en').split('-')[0];
    const url = `https://api.mymemory.translated.net/get?q=${q}&langpair=${fromRoot}|${toRoot}`;
    const res = await fetch(url);
    const json = await res.json();
    return (json && json.responseData && json.responseData.translatedText) ? json.responseData.translatedText : '(translation failed)';
  } catch (e) {
    console.warn('translate error', e);
    return '(translation failed)';
  }
}

/* -------------------------
   Commit logic: translate + UI + optional TTS
   - Avoid duplicates via lastCommittedFinal
   ------------------------- */
async function commitChunk(rawText) {
  const cleaned = cleanTranscript(rawText);
  if (!cleaned) return;
  if (cleaned === lastCommittedFinal) return; // skip duplicates
  lastCommittedFinal = cleaned;

  // For UX: show it in liveText while fetching (non-blocking)
  liveText.textContent = 'üéôÔ∏è ' + cleaned;

  const from = fromLang.value || 'en-US';
  const to = toLang.value || 'en';
  const translated = await translateText(cleaned, from, to);

  addTranslation(cleaned, translated);

  if (audioEnabled) {
    speak(translated, langSpeechMap[to] || to);
  }
}

/* -------------------------
   Recognition initialization (Android-friendly)
   - continuous = true, interimResults = true
   - robust handling of Android multiple finals
   - pause-based fallback commit for devices that don't finalise cleanly
   ------------------------- */
function initRecognition() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert('Speech recognition not supported in this browser.');
    return null;
  }

  const r = new SpeechRecognition();
  r.continuous = true;
  r.interimResults = true;
  r.lang = fromLang.value || 'en-US';

  const PAUSE_MS = 900; // pause length to treat interim as committed fallback

  r.onresult = (event) => {
    // Cancel any pending pause timer (we're receiving updates)
    if (silenceTimer) {
      clearTimeout(silenceTimer);
      silenceTimer = null;
    }

    // event.results can contain a mix of interim and final parts
    // We'll collect final parts (if any) and also capture the latest interim
    let finals = [];
    let latestInterim = '';

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const res = event.results[i];
      const txt = (res[0] && res[0].transcript) ? res[0].transcript.trim() : '';
      if (!txt) continue;
      if (res.isFinal) finals.push(txt);
      else latestInterim = txt;
    }

    if (finals.length > 0) {
      // Combine multiple finals into a single commit (Android sometimes splits)
      const combined = finals.join(' ');
      const cleaned = cleanTranscript(combined);
      liveText.textContent = 'üéôÔ∏è ' + cleaned;
      commitChunk(cleaned);
      interimBuffer = '';
    } else if (latestInterim) {
      // Show interim live, but do not commit immediately; set a pause timer to fallback commit
      interimBuffer = latestInterim;
      liveText.textContent = 'üéôÔ∏è ' + cleanTranscript(latestInterim);

      silenceTimer = setTimeout(() => {
        silenceTimer = null;
        if (interimBuffer && interimBuffer !== lastCommittedFinal) {
          const fallback = cleanTranscript(interimBuffer);
          if (fallback) commitChunk(fallback);
          interimBuffer = '';
        }
      }, PAUSE_MS);
    }
  };

  r.onerror = (e) => {
    console.warn('recognition error', e);
  };

  r.onend = () => {
    // When recognition stops unexpectedly, maintain UX and optionally restart if user expects listening.
    isListening = false;
    toggleBtn.textContent = 'Start';

    // If there was remaining interim text, commit it once as a fallback
    if (interimBuffer && interimBuffer !== lastCommittedFinal) {
      const fallback = cleanTranscript(interimBuffer);
      if (fallback) commitChunk(fallback);
      interimBuffer = '';
    }

    // If user did not explicitly stop, auto-restart to maintain continuous stream on Android
    if (shouldAutoRestart) {
      setTimeout(() => {
        try {
          r.start();
          isListening = true;
          toggleBtn.textContent = 'Stop';
        } catch (e) {
          console.warn('auto-restart failed', e);
        }
      }, 350);
    }
  };

  return r;
}

/* -------------------------
   Start / Stop logic
   ------------------------- */
function startListening() {
  if (isListening) return;
  // create recognition if not present
  if (!recognition) {
    recognition = initRecognition();
    if (!recognition) return;
  } else {
    // update language if changed
    recognition.lang = fromLang.value || recognition.lang;
  }

  shouldAutoRestart = true;
  try {
    recognition.start();
    isListening = true;
    toggleBtn.textContent = 'Stop';
    liveText.textContent = 'üéôÔ∏è Listening...';
  } catch (e) {
    console.warn('start error', e);
  }
}

function stopListening() {
  shouldAutoRestart = false;
  if (silenceTimer) {
    clearTimeout(silenceTimer);
    silenceTimer = null;
  }
  if (!recognition) return;
  try {
    recognition.stop();
  } catch (e) {
    console.warn('stop error', e);
  }
  isListening = false;
  toggleBtn.textContent = 'Start';
  // commit last interim as fallback
  if (interimBuffer && interimBuffer !== lastCommittedFinal) {
    commitChunk(cleanTranscript(interimBuffer));
    interimBuffer = '';
  }
}

/* -------------------------
   UI event wiring
   ------------------------- */
enableAudioBtn.addEventListener('click', () => {
  try {
    const u = new SpeechSynthesisUtterance('Audio enabled');
    speechSynthesis.speak(u);
    audioEnabled = true;
    enableAudioBtn.disabled = true;
    enableAudioBtn.textContent = 'Audio Enabled';
    enableAudioBtn.classList.remove('ghost');
  } catch (e) {
    console.warn('TTS enable failed', e);
  }
});

toggleBtn.addEventListener('click', () => {
  if (!isListening) startListening();
  else stopListening();
});

replayAllBtn.addEventListener('click', () => {
  if (!allTranslations.length) {
    alert('No translations to replay.');
    return;
  }
  // Play in chronological order (oldest first)
  const queue = allTranslations.slice().reverse();
  queue.forEach((text, i) => {
    setTimeout(() => speak(text, langSpeechMap[toLang.value] || toLang.value), i * 1400);
  });
});

clearBtn.addEventListener('click', () => {
  if (!confirm('Clear all translations?')) return;
  translationsDiv.innerHTML = '';
  allTranslations = [];
  lastCommittedFinal = '';
  interimBuffer = '';
  speechSynthesis.cancel();
});

fromLang.addEventListener('change', () => {
  // if changing language while listening, restart recognizer to take new lang
  if (isListening) {
    stopListening();
    setTimeout(startListening, 200);
  }
});

/* -------------------------
   Defensive / cleanup
   ------------------------- */
// Ensure voices populate
window.speechSynthesis.onvoiceschanged = () => { /* no-op */ };

// Stop TTS & recognition on unload
window.addEventListener('beforeunload', () => {
  shouldAutoRestart = false;
  try { stopListening(); } catch (e) {}
  try { speechSynthesis.cancel(); } catch (e) {}
});

</script>
</body>
</html>
